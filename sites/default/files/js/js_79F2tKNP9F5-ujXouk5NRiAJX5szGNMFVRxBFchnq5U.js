/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/

(function (Drupal, debounce, CKEDITOR, $, displace, AjaxCommands) {
  Drupal.editors.ckeditor = {
    attach: function attach(element, format) {
      this._loadExternalPlugins(format);

      format.editorSettings.drupal = {
        format: format.format
      };

      var label = $('label[for=' + element.getAttribute('id') + ']').html();
      format.editorSettings.title = Drupal.t('Rich Text Editor, !label field', {
        '!label': label
      });

      return !!CKEDITOR.replace(element, format.editorSettings);
    },
    detach: function detach(element, format, trigger) {
      var editor = CKEDITOR.dom.element.get(element).getEditor();
      if (editor) {
        if (trigger === 'serialize') {
          editor.updateElement();
        } else {
          editor.destroy();
          element.removeAttribute('contentEditable');
        }
      }
      return !!editor;
    },
    onChange: function onChange(element, callback) {
      var editor = CKEDITOR.dom.element.get(element).getEditor();
      if (editor) {
        editor.on('change', debounce(function () {
          callback(editor.getData());
        }, 400));

        editor.on('mode', function () {
          var editable = editor.editable();
          if (!editable.isInline()) {
            editor.on('autoGrow', function (evt) {
              var doc = evt.editor.document;
              var scrollable = CKEDITOR.env.quirks ? doc.getBody() : doc.getDocumentElement();

              if (scrollable.$.scrollHeight < scrollable.$.clientHeight) {
                scrollable.setStyle('overflow-y', 'hidden');
              } else {
                scrollable.removeStyle('overflow-y');
              }
            }, null, null, 10000);
          }
        });
      }
      return !!editor;
    },
    attachInlineEditor: function attachInlineEditor(element, format, mainToolbarId, floatedToolbarId) {
      this._loadExternalPlugins(format);

      format.editorSettings.drupal = {
        format: format.format
      };

      var settings = $.extend(true, {}, format.editorSettings);

      if (mainToolbarId) {
        var settingsOverride = {
          extraPlugins: 'sharedspace',
          removePlugins: 'floatingspace,elementspath',
          sharedSpaces: {
            top: mainToolbarId
          }
        };

        var sourceButtonFound = false;
        for (var i = 0; !sourceButtonFound && i < settings.toolbar.length; i++) {
          if (settings.toolbar[i] !== '/') {
            for (var j = 0; !sourceButtonFound && j < settings.toolbar[i].items.length; j++) {
              if (settings.toolbar[i].items[j] === 'Source') {
                sourceButtonFound = true;

                settings.toolbar[i].items[j] = 'Sourcedialog';
                settingsOverride.extraPlugins += ',sourcedialog';
                settingsOverride.removePlugins += ',sourcearea';
              }
            }
          }
        }

        settings.extraPlugins += ',' + settingsOverride.extraPlugins;
        settings.removePlugins += ',' + settingsOverride.removePlugins;
        settings.sharedSpaces = settingsOverride.sharedSpaces;
      }

      element.setAttribute('contentEditable', 'true');

      return !!CKEDITOR.inline(element, settings);
    },
    _loadExternalPlugins: function _loadExternalPlugins(format) {
      var externalPlugins = format.editorSettings.drupalExternalPlugins;

      if (externalPlugins) {
        Object.keys(externalPlugins || {}).forEach(function (pluginName) {
          CKEDITOR.plugins.addExternal(pluginName, externalPlugins[pluginName], '');
        });
        delete format.editorSettings.drupalExternalPlugins;
      }
    }
  };

  Drupal.ckeditor = {
    saveCallback: null,

    openDialog: function openDialog(editor, url, existingValues, saveCallback, dialogSettings) {
      var $target = $(editor.container.$);
      if (editor.elementMode === CKEDITOR.ELEMENT_MODE_REPLACE) {
        $target = $target.find('.cke_contents');
      }

      $target.css('position', 'relative').find('.ckeditor-dialog-loading').remove();

      var classes = dialogSettings.dialogClass ? dialogSettings.dialogClass.split(' ') : [];
      classes.push('ui-dialog--narrow');
      dialogSettings.dialogClass = classes.join(' ');
      dialogSettings.autoResize = window.matchMedia('(min-width: 600px)').matches;
      dialogSettings.width = 'auto';

      var $content = $('<div class="ckeditor-dialog-loading"><span style="top: -40px;" class="ckeditor-dialog-loading-link">' + Drupal.t('Loading...') + '</span></div>');
      $content.appendTo($target);

      var ckeditorAjaxDialog = Drupal.ajax({
        dialog: dialogSettings,
        dialogType: 'modal',
        selector: '.ckeditor-dialog-loading-link',
        url: url,
        progress: { type: 'throbber' },
        submit: {
          editor_object: existingValues
        }
      });
      ckeditorAjaxDialog.execute();

      window.setTimeout(function () {
        $content.find('span').animate({ top: '0px' });
      }, 1000);

      Drupal.ckeditor.saveCallback = saveCallback;
    }
  };

  $(window).on('dialogcreate', function (e, dialog, $element, settings) {
    $('.ui-dialog--narrow').css('zIndex', CKEDITOR.config.baseFloatZIndex + 1);
  });

  $(window).on('dialog:beforecreate', function (e, dialog, $element, settings) {
    $('.ckeditor-dialog-loading').animate({ top: '-40px' }, function () {
      $(this).remove();
    });
  });

  $(window).on('editor:dialogsave', function (e, values) {
    if (Drupal.ckeditor.saveCallback) {
      Drupal.ckeditor.saveCallback(values);
    }
  });

  $(window).on('dialog:afterclose', function (e, dialog, $element) {
    if (Drupal.ckeditor.saveCallback) {
      Drupal.ckeditor.saveCallback = null;
    }
  });

  $(document).on('drupalViewportOffsetChange', function () {
    CKEDITOR.config.autoGrow_maxHeight = 0.7 * (window.innerHeight - displace.offsets.top - displace.offsets.bottom);
  });

  function redirectTextareaFragmentToCKEditorInstance() {
    var hash = window.location.hash.substr(1);
    var element = document.getElementById(hash);
    if (element) {
      var editor = CKEDITOR.dom.element.get(element).getEditor();
      if (editor) {
        var id = editor.container.getAttribute('id');
        window.location.replace('#' + id);
      }
    }
  }
  $(window).on('hashchange.ckeditor', redirectTextareaFragmentToCKEditorInstance);

  CKEDITOR.config.autoGrow_onStartup = true;

  CKEDITOR.timestamp = drupalSettings.ckeditor.timestamp;

  if (AjaxCommands) {
    AjaxCommands.prototype.ckeditor_add_stylesheet = function (ajax, response, status) {
      var editor = CKEDITOR.instances[response.editor_id];

      if (editor) {
        response.stylesheets.forEach(function (url) {
          editor.document.appendStyleSheet(url);
        });
      }
    };
  }
})(Drupal, Drupal.debounce, CKEDITOR, jQuery, Drupal.displace, Drupal.AjaxCommands);;
/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/

(function ($, CKEDITOR) {
  var convertToOffCanvasCss = function convertToOffCanvasCss(originalCss) {
    var selectorPrefix = '#drupal-off-canvas ';
    var skinPath = '' + CKEDITOR.basePath + CKEDITOR.skinName + '/';
    var css = originalCss.substring(originalCss.indexOf('*/') + 2).trim().replace(/}/g, '}' + selectorPrefix).replace(/,/g, ',' + selectorPrefix).replace(/url\(/g, skinPath);
    return '' + selectorPrefix + css;
  };

  var insertCss = function insertCss(cssToInsert) {
    var offCanvasCss = document.createElement('style');
    offCanvasCss.innerHTML = cssToInsert;
    offCanvasCss.setAttribute('id', 'ckeditor-off-canvas-reset');
    document.body.appendChild(offCanvasCss);
  };

  var addCkeditorOffCanvasCss = function addCkeditorOffCanvasCss() {
    if (document.getElementById('ckeditor-off-canvas-reset')) {
      return;
    }

    CKEDITOR.skinName = CKEDITOR.skin.name;

    var editorCssPath = CKEDITOR.skin.getPath('editor');
    var dialogCssPath = CKEDITOR.skin.getPath('dialog');

    var storedOffCanvasCss = window.localStorage.getItem('Drupal.off-canvas.css.' + editorCssPath + dialogCssPath);

    if (storedOffCanvasCss) {
      insertCss(storedOffCanvasCss);
      return;
    }

    $.when($.get(editorCssPath), $.get(dialogCssPath)).done(function (editorCss, dialogCss) {
      var offCanvasEditorCss = convertToOffCanvasCss(editorCss[0]);
      var offCanvasDialogCss = convertToOffCanvasCss(dialogCss[0]);
      var cssToInsert = '#drupal-off-canvas .cke_inner * {background: transparent;}\n          ' + offCanvasEditorCss + '\n          ' + offCanvasDialogCss;
      insertCss(cssToInsert);

      if (CKEDITOR.timestamp && editorCssPath.indexOf(CKEDITOR.timestamp) !== -1 && dialogCssPath.indexOf(CKEDITOR.timestamp) !== -1) {
        window.localStorage.setItem('Drupal.off-canvas.css.' + editorCssPath + dialogCssPath, cssToInsert);
      }
    });
  };

  addCkeditorOffCanvasCss();
})(jQuery, CKEDITOR);;
/**
 * @file
 * Custom library creating cross-browser support for the JS History API.
 */

/*global Drupal, window*/
/*jslint white:true, this, browser:true*/

Drupal.history = {};

(function (Drupal, window) {
  "use strict";

  Drupal.behaviors.historyApi = {
    attach: function () {
      Drupal.history.push = function (data, title, url) {
        if (window.history && window.history.pushState) {
          window.history.pushState(data, title, url);
        }
      };
    }
  };
}(Drupal, window));

/**
 * Ensures the JavaScript History API works consistently between browsers.
 *
 * @optimize spin this out into a file that is only called on pages that specifically
 * use the History API
 */
(function (window) {
  "use strict";

  // There's nothing to do for older browsers ;)
  if (!window.addEventListener) {
    return;
  }

  var blockPopstateEvent = document.readyState !== "complete";

  window.addEventListener("load", function () {
    // The timeout ensures that popstate-events will be unblocked right
    // after the load event occured, but not in the same event-loop cycle.
    window.setTimeout(function () { blockPopstateEvent = false; }, 0);
  }, false);

  window.addEventListener("popstate", function (evt) {
    if (blockPopstateEvent && document.readyState === "complete") {
      evt.preventDefault();
      evt.stopImmediatePropagation();
    }
  }, false);
}(window));
;
/**
 * @file
 * Adds JavaScript functionality to priveate message threads.
 */

/*global jQuery, Drupal, drupalSettings, window*/
/*jslint white:true, this, browser:true*/

Drupal.PrivateMessages = {};
Drupal.PrivateMessages.threadChange = {};

(function ($, Drupal, drupalSettings, window) {

  "use strict";

  var initialized, threadWrapper, currentThreadId, originalThreadId, loadingPrev, loadingNew, container, timeout, refreshRate, dimmer, loadingThread;

  /**
   * Triggers AJAX commands when they happen outside the Form API framework.
   */
  function triggerCommands(data) {
    var ajaxObject = Drupal.ajax({
      url: "",
      base: false,
      element: false,
      progress: false
    });

    // Trigger any any ajax commands in the response.
    ajaxObject.success(data, "success");
  }

  function showDimmer(callback) {
    if (!dimmer) {
      dimmer = $("<div/>", {id:"private-message-thread-dimmer"}).appendTo(threadWrapper);
    }

    dimmer.fadeTo(500, 0.8, callback);
  }

  function hideDimmer() {
    if (dimmer) {
      dimmer.fadeOut(500);
    }
  }

  /**
   * Click handler for the button to load previous private messages.
   */
  var loadPreviousListenerHandler = function (e) {
    e.preventDefault();

    // Ensure that a load isn't already in progress.
    if (!loadingPrev) {
      loadingPrev = true;

      var threadId, oldestId;

      // Get the thread ID.
      threadId = threadWrapper.children(".private-message-thread:first").attr("data-thread-id");

      // Get the ID of the oldest message. This will be used for reference to
      // tell the server which messages it should send back.
      container.find(".private-message").each(function () {
        if (!oldestId || Number($(this).attr("data-message-id")) < oldestId) {
          oldestId = Number($(this).attr("data-message-id"));
        }
      });

      // Retrieve messages from the server with an AJAX callback.
      $.ajax({
        url:drupalSettings.privateMessageThread.previousMessageCheckUrl,
        data: {threadid:threadId, messageid:oldestId},
        success:function (data) {
          loadingPrev = false;
          // Trigger the AJAX commands that were returned from the server.
          triggerCommands(data);
        }
      });
    }
  };

  /**
   * Attaches event handlers to the load previous messages button.
   */
  function loadPreviousListener(context) {
    $(context).find("#load-previous-messages").once("load-previous-private-messages-listener").each(function () {
      $(this).click(loadPreviousListenerHandler);
    });
  }

  /**
   * Function to attach behaviors to HTML.
   */
  function htmlAttachBehaviors(html) {
    // Find the node element when Twig debug is enabled.
    for (var i=0; i < html.length; i++) {
      if (html[i].nodeType === 1) {
        Drupal.attachBehaviors(html[i]);
      }
    }
  }

  /**
   * Inserts new messages into the thread.
   */
  function insertNewMessages(messages) {
    // Render the messages as HTML, and set them to be hidden.
    var html = $("<div/>").html(messages).contents().css("display", "none");

    // Insert the messages into the thread.
    if (drupalSettings.privateMessageThread.messageOrder === "asc") {
      html.appendTo(container);
    }
    else {
      html.prependTo(container);
    }

    // Show the messages.
    html.slideDown(300);
    htmlAttachBehaviors(html);
  }

  // Insert older messages into the thread.
  function insertPreviousMessages(messages) {
    // Render the messages as HTML, setting them to be hidden.
    var html = $("<div/>").html(messages).contents().css("display", "none");

    // Insert the messages into the thread.
    if (drupalSettings.privateMessageThread.messageOrder === "asc") {
      html.prependTo(container);
    }
    else {
      html.appendTo(container);
    }

    // Show the messages.
    html.slideDown(300);
    htmlAttachBehaviors(html);
  }

  /**
   * Retrieves new messages from the server.
   */
  function getNewMessages() {
    // Only attempt a retrieval if one is not already in progress.
    if (!loadingNew) {
      var threadId, newestId = 0;

      loadingNew = true;

      // Get the thread ID.
      threadId = threadWrapper.children(".private-message-thread:first").attr("data-thread-id");

      // Get the ID of the newest message. This will be used as a reference
      // server side to determine which messages to return to the browser.
      container.find(".private-message").each(function () {
        if (Number($(this).attr("data-message-id")) > newestId) {
          newestId = Number($(this).attr("data-message-id"));
        }
      });

      $.ajax({
        url:drupalSettings.privateMessageThread.newMessageCheckUrl,
        data: {threadid:threadId, messageid:newestId},
        success:function (data) {
          triggerCommands(data);

          loadingNew = false;

          if (refreshRate) {
             // Check for new messages again.
            timeout = window.setTimeout(getNewMessages, refreshRate);
          }
        }
      });
    }
  }

  /**
   * Remove the existing thread from the DOM, and insert a new one in its place.
   */
  function insertThread(thread) {
    var newThread, originalThread;

    // Render the new thread as HTML.
    newThread = $("<div/>").html(thread).find(".private-message-thread:first");
    // Find the current thread in the DOM.
    originalThread = threadWrapper.children(".private-message-thread:first");
    // Detach any behaviors from the old thread, to prevent memory leaks.
    Drupal.detachBehaviors(threadWrapper[0]);
    // Insert the new thread into the DOM.
    newThread.insertAfter(originalThread);
    // Remove the old thread from teh DOM.
    originalThread.remove();

    // Attach any behaviors to the new thread.
    Drupal.attachBehaviors(threadWrapper[0]);

    hideDimmer();
  }

  /**
   * Loads a thread from the server.
   */
  function loadThread(threadId, pushHistory) {
    // Only try loading the thread if a thread isn't already loading, and if the
    // requested thread is not the current thread.
    if (!loadingThread && threadId !== currentThreadId) {
      loadingThread = true;

      window.clearTimeout(timeout);

      showDimmer();

      // Load the new thread from the server with AJAX.
      $.ajax({
        url:drupalSettings.privateMessageThread.loadThreadUrl,
        data:{id:threadId},
        success:function (data) {
          triggerCommands(data);

          if (Drupal.PrivateMessages.setActiveThread) {
            Drupal.PrivateMessages.setActiveThread(threadId);
          }

          loadingThread = false;

          timeout = window.setTimeout(getNewMessages, refreshRate);
        }
      });

      // The thread ID is changing. As such, we tell any other scripts that want
      // to know, that the thread has changed, and what the new thread ID is.
      Drupal.PrivateMessages.emitNewThreadId(threadId);

      // Change the URl if using a browser that allows it.
      if (pushHistory) {
        Drupal.history.push({threadId:threadId}, $("title").text(), "/private-messages/" + threadId);
      }
    }
  }

  function init() {
    // Find the wrapper for the current thread.
    threadWrapper = $(".private-message-thread-full").parent();
    insertPreviousButton(threadWrapper);

    if (!initialized) {
      initialized = true;

      // Get the original thread ID on page load.
      originalThreadId = threadWrapper.children(".private-message-thread:first").attr("data-thread-id");

      // If the refresh rate is anything above zero (zero is disabled) start the
      // server polling for new messages.
      if (refreshRate) {
        timeout = window.setTimeout(getNewMessages, refreshRate);
      }

      // Set the active thread.
      if (Drupal.PrivateMessages.setActiveThread) {
        Drupal.PrivateMessages.setActiveThread(originalThreadId);
      }
    }
  }

  /**
   * Insert button to load previous thread messages.
   */
  function insertPreviousButton(threadWrapper) {
    if (threadWrapper.find('#load-previous-messages').length === 0 && drupalSettings.privateMessageThread.messageTotal > drupalSettings.privateMessageThread.messageCount) {
      // Initialize the previous button. This will be inserted into the thread.
      var loadPreviousButton;

      // Get the rate (in seconds) after which the server should be polled for
      // new messages.
      refreshRate = drupalSettings.privateMessageThread.refreshRate;
      // Get the container for messages.
      container = threadWrapper.find(".private-message-thread-messages:first .private-message-wrapper:first").parent();

      // Don't add the load previous button if the thread is completely loaded.
      if (!container.hasClass('js-completely-loaded')) {
        // Create the HTML for the load previous button.
        loadPreviousButton = $("<div/>", {id:"load-previous-messages-button-wrapper"}).append($("<a/>", {href:"#", id:"load-previous-messages"}).text(Drupal.t("Load Previous")));

        // Insert the load previous button into the DOM.
        if (drupalSettings.privateMessageThread.messageOrder === "asc") {
          loadPreviousButton.addClass("load-previous-position-before").insertBefore(container);
        }
        else {
          loadPreviousButton.addClass("load-previous-position-after").insertAfter(container);
        }
      }
    }
  }

  Drupal.behaviors.privateMessageThread = {
    attach:function (context) {
      init();
      loadPreviousListener(context);
      currentThreadId = threadWrapper.children(".private-message-thread:first").attr("data-thread-id");
      container = threadWrapper.find(".private-message-thread-messages:first .private-message-wrapper:first").parent();

      // Ajax commands insertPrivateMessages command callback.
      Drupal.AjaxCommands.prototype.insertPrivateMessages = function (ajax, response) {
        // Stifles jSlint warning.
        ajax = ajax;

        if (response.insertType === "new") {
          insertNewMessages(response.messages);
        }
        else {
          if (response.messages) {
            insertPreviousMessages(response.messages);
          }
          if (!response.hasNext) {
            container.addClass('js-completely-loaded');
            $("#load-previous-messages").parent().slideUp(300, function () {
              $(this).remove();
            });
          }
        }
      };

      // Ajax commands loadNewPrivateMessages command callback.
      Drupal.AjaxCommands.prototype.loadNewPrivateMessages = function () {

        window.clearTimeout(timeout);

        getNewMessages();
      };

      // Ajax commands privateMessageInsertThread command callback.
      Drupal.AjaxCommands.prototype.privateMessageInsertThread = function (ajax, response) {
        // Stifle jslint warning.
        ajax = ajax;

        if (response.thread && response.thread.length) {
          insertThread(response.thread);
        }
      };

      // Lets other modules trigger the loading of a new thread into the page.
      Drupal.PrivateMessages.loadThread = function (threadId) {
        loadThread(threadId, true);
      };

      // Lets other modules trigger a retrieval of new messages from the server.
      Drupal.PrivateMessages.getNewMessages = function () {
        getNewMessages();
      };

      // Tells other modules the ID of a new thread that has been inserted into
      // the page.
      Drupal.PrivateMessages.emitNewThreadId = function (threadId) {
        $.each(Drupal.PrivateMessages.threadChange, function (index) {
          if (Drupal.PrivateMessages.threadChange[index].threadLoaded) {
            Drupal.PrivateMessages.threadChange[index].threadLoaded(threadId);
          }
        });
      };
    },
    detach:function (context) {
      $(context).find("#load-previous-messages").unbind("click", loadPreviousListenerHandler);
    }
  };

  // Integrates the script with the previous/next buttons in the browser.
  window.onpopstate = function (e) {
    if (e.state && e.state.threadId) {
      loadThread(e.state.threadId);
    }
    else {
      loadThread(originalThreadId);
    }
  };

}(jQuery, Drupal, drupalSettings, window));
;
